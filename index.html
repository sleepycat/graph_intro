<!DOCTYPE html>
<html>
  <head>
    <title>Serving connected data</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="stylesheets/style.css" >
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Thinking in graphs

## Mike Williamson and Jen Schellinck

---
class: center, middle

.quote["No data is born relational" -- Dharma Shukla, Microsoft]

???
This is a really interesting quote from Microsoft Technical Fellow Dharma Shukla.
---
class: center, middle

## Relational data

.seventy[![schema](images/hr_schema.png)]

???
If data isn't born relational, how does it get like this?
---

background-image: url(images/golden_hammer_bg.jpg)

???
Programmers are trained to be able bash data of any shape into the shape of a table.
What shape was the data before the golden hammer was weilded? Probably a graph.
Have we lost anything by bashing it into this new shape?
---
class: center, middle

# Types of graph

.eighty[![types](images/graph_types.png)]

???
---
class: center, middle

# Sequencing

.twenty[![dependency graph?](images/dependency_graph.png)]

???
Isn't that a dependency graph? Shouldn't we explicitly model the relationships?
---

class: center, middle

# Interconnections

.sixty[![explosion](images/connectome.jpg)]

???
---

class: center, middle

# Heirarchy

.eighty[![explosion](images/parts_explosion.jpg)]

???
Heirarchical things
---

class: center, middle

# Data can be represented either way: tables or a graph
.eighty[![equivalent](images/equivalent.png)]

???
You are looking the same data represented on the left as tables and on the right as a graph.
When most people think of data, it's primarily tables or lists of data that comes to mind.
But this is not the only, or even best way to store all data.
The real world contains many things that are challenging to store in a standard database
---
class: center, middle

# Interconnection example

???
Any join operation could be considered a graph traversal.
Complicated relationships like authors/books or employees/projects are especially painful.
This is called a many to many relationship and it requires three tables in a relational database.
---
class: center, middle

.eighty[![m2m](images/many_to_many.png)]

???
---
class: middle

## Relational setup

```sh
CREATE TABLE IF NOT EXISTS projects (id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, name VARCHAR(45) NULL);
CREATE TABLE IF NOT EXISTS employees (id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, name VARCHAR(45) NULL);
CREATE TABLE IF NOT EXISTS employees_projects (employee_id INT NOT NULL, project_id INT NOT NULL, PRIMARY KEY (project_id, employee_id), FOREIGN KEY(employee_id) REFERENCES employees(id), FOREIGN KEY(project_id) REFERENCES projects(id));

INSERT INTO employees VALUES (null, "Mike");
INSERT INTO projects VALUES (null, "Bigproj");
INSERT INTO employees_projects VALUES (1, 1);
```
???
Then a table structure is created and finally the categories and the numbers
which denote their level of nesting
---
class: middle

## What project is Mike working on?
```sh
select employees.name, projects.name from employees
	inner join employees_projects
    on employees.id = employees_projects.employee_id
  inner join projects
    on employees_projects.project_id = projects.id;

Mike|Bigproj
```
???
---
class: middle

## Graph setup
```sh
db._createDocumentCollection('projects')
db._createDocumentCollection('employees')
db._createEdgeCollection('works_on')

INSERT {_key: "mike", name: "Mike"} INTO employees
INSERT {_key: "bigproj", name: "Bigproj"} INTO projects
INSERT {_to: "projects/bigproj", _from: "employees/mike"} INTO works_on
```
???
---
class: middle

## What project is Mike working on?
```sh
FOR v IN OUTBOUND "employees/mike" works_on RETURN v

[
  {
    "_key" : "bigproj",
    "_id" : "projects/bigproj",
    "_rev" : "_VFm2yp----",
    "name" : "Bigproj"
  }
]
```
???
Low ceremony, no rules about what attributes a any of our vertices can have.
---
class: center, middle

# Heirarchy example

???
Heirarchical data is famously awkward to store in relational database.
We'll explore the Nested Sets design pattern and compare it with a graph approach.
---
class: center, middle

# Representing heirarchies in relational databases is weird
.eighty[![categories](images/categories.png)]

???
---
class: center, middle

# A popular strategy: The Nested Sets pattern
.eighty[![numbered](images/nested_numbered.png)]

???
Here is the planning phase, where you decide what numbers the categories are
going to have relative to each other.
---
class: middle

## Nested Sets
```sh
CREATE TABLE nested_category (
        category_id INT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(20) NOT NULL,
        lft INT NOT NULL,
        rgt INT NOT NULL
);

INSERT INTO nested_category VALUES(1,'ELECTRONICS',1,20),(2,'TELEVISIONS',2,9),(3,'TUBE',3,4),
 (4,'LCD',5,6),(5,'PLASMA',7,8),(6,'PORTABLE ELECTRONICS',10,19),(7,'MP3 PLAYERS',11,14),(8,'FLASH',12,13),
 (9,'CD PLAYERS',15,16),(10,'2 WAY RADIOS',17,18);
```
???
Then a table structure is created and finally the categories and the numbers
which denote their level of nesting
---
class: center, middle

```sh
SELECT * FROM nested_category ORDER BY category_id;

+-------------+----------------------+-----+-----+
| category_id | name                 | lft | rgt |
+-------------+----------------------+-----+-----+
|           1 | ELECTRONICS          |   1 |  20 |
|           2 | TELEVISIONS          |   2 |   9 |
|           3 | TUBE                 |   3 |   4 |
|           4 | LCD                  |   5 |   6 |
|           5 | PLASMA               |   7 |   8 |
|           6 | PORTABLE ELECTRONICS |  10 |  19 |
|           7 | MP3 PLAYERS          |  11 |  14 |
|           8 | FLASH                |  12 |  13 |
|           9 | CD PLAYERS           |  15 |  16 |
|          10 | 2 WAY RADIOS         |  17 |  18 |
+-------------+----------------------+-----+-----+
```
???
The result
---
class: middle

# Representing heirarchy in graphs...

```sh
//Categories collection
[
  {
    "_key" : "1318641957494",
    "_id" : "categories/1318641957494",
    "_rev" : "_VFQ3KPy---",
    "name" : "electronics"
  },
  {
    "_key" : "1318641957725",
    "_id" : "categories/1318641957725",
    "_rev" : "_VFQ57P----",
    "name" : "portable electronics"
  },
...
]
//Relations collection
[
  {
    "_key" : "1318641957818",
    "_id" : "relations/1318641957818",
    "_from" : "categories/1318641957725",
    "_to" : "categories/1318641957494",
    "_rev" : "_VFQ6xPu---"
  },
...
]
```
???
A graph would simply have a collection of categories. Relations are not
calculated on the fly, they are saved as data as well: another collection
containing edges
---
class: center, middle

# Retrieving a full tree

---

class: middle

```sh

SELECT node.name
FROM nested_category AS node,
        nested_category AS parent
WHERE node.lft BETWEEN parent.lft AND parent.rgt
        AND parent.name = 'ELECTRONICS'
ORDER BY node.lft;

+----------------------+
| name                 |
+----------------------+
| ELECTRONICS          |
| TELEVISIONS          |
| TUBE                 |
| LCD                  |
| PLASMA               |
| PORTABLE ELECTRONICS |
| MP3 PLAYERS          |
| FLASH                |
| CD PLAYERS           |
| 2 WAY RADIOS         |
+----------------------+
```
???
---
class: middle

```sh
LET root = DOCUMENT("categories/1318641957494")
LET subcategories = (FOR v IN 1..3 INBOUND root relations RETURN v.name)
RETURN FLATTEN([root.name, subcategories])

[
	"electronics",
	"televisions",
	"lcd",
	"plasma",
	"tube",
	"portable electronics",
	"mp3 players",
	"flash",
	"2 way radios",
	"cd players"
]
```
???
---
class: center, middle

# Finding all the leaf nodes

---

class: middle

```sh
SELECT name
FROM nested_category
WHERE rgt = lft + 1;

+--------------+
| name         |
+--------------+
| TUBE         |
| LCD          |
| PLASMA       |
| FLASH        |
| CD PLAYERS   |
| 2 WAY RADIOS |
+--------------+
```
???
---
class: middle

```sh
FOR vertex IN 2..3 INBOUND {_id: "categories/1318641957494"} relations
FILTER LENGTH(FOR v IN 1 INBOUND vertex relations RETURN v) == 0
RETURN vertex.name

[
  "lcd",
  "plasma",
  "tube",
  "flash",
  "2 way radios",
  "cd players"
]
```
???
---
class: center, middle

# Find the immediate subordinates of a node

---

class: middle

```sh

SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth
FROM nested_category AS node,
        nested_category AS parent,
        nested_category AS sub_parent,
        (
                SELECT node.name, (COUNT(parent.name) - 1) AS depth
                FROM nested_category AS node,
                        nested_category AS parent
                WHERE node.lft BETWEEN parent.lft AND parent.rgt
                        AND node.name = 'PORTABLE ELECTRONICS'
                GROUP BY node.name
                ORDER BY node.lft
        )AS sub_tree
WHERE node.lft BETWEEN parent.lft AND parent.rgt
        AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt
        AND sub_parent.name = sub_tree.name
GROUP BY node.name
HAVING depth <= 1
ORDER BY node.lft;

+----------------------+-------+
| name                 | depth |
+----------------------+-------+
| PORTABLE ELECTRONICS |     0 |
| MP3 PLAYERS          |     1 |
| CD PLAYERS           |     1 |
| 2 WAY RADIOS         |     1 |
+----------------------+-------+
```
???
---
class: middle

```sh
LET root = (FOR category IN categories FILTER category.name == "portable electronics" RETURN category)[0]
LET subcategories = (FOR v,e,p IN INBOUND root relations RETURN {name: v.name, depth: LENGTH(p.edges)})
RETURN UNSHIFT(FLATTEN(subcategories), {name: root.name, depth: 0})

[
  [
    {
      "name" : "portable electronics",
      "depth" : 0
    },
    {
      "name" : "mp3 players",
      "depth" : 1
    },
    {
      "name" : "2 way radios",
      "depth" : 1
    },
    {
      "name" : "cd players",
      "depth" : 1
    }
  ]
]
```
???
---
class: center, middle

# Adding a category

---
class: middle

```sh
LOCK TABLE nested_category WRITE;

SELECT @myRight := rgt FROM nested_category
WHERE name = 'TELEVISIONS';

UPDATE nested_category SET rgt = rgt + 2 WHERE rgt > @myRight;
UPDATE nested_category SET lft = lft + 2 WHERE lft > @myRight;

INSERT INTO nested_category(name, lft, rgt) VALUES('GAME CONSOLES', @myRight + 1, @myRight + 2);

UNLOCK TABLES;
```
???
---
class: middle

```sql
//insert new category
INSERT {name: "game consoles"} INTO categories RETURN NEW
[
  {
    "_key" : "1318641997534",
    "_id" : "categories/1318641997534",
    "_rev" : "_VFX942S---",
    "name" : "game consoles"
  }
]

//insert a edge connecting the new category to it's parent
INSERT {_to: "categories/1318641957494", _from: "categories/1318641997534"} INTO relations RETURN NEW
[
  {
    "_key" : "1318641997709",
    "_id" : "relations/1318641997709",
    "_from" : "categories/1318641997534",
    "_to" : "categories/1318641957494",
    "_rev" : "_VFY_tou---"
  }
]


```
???

---
class: center, middle

# What did this graph stuff get us?

* Change is simple
* Less upfront planning/no "design patterns"
* Scaling == more machines
* Dealing with heirarchy/connections/etc does not acummulate complexity
* Lists of stuff is not hard under either model

???
Queries are an interesting point of comparison but the real value is in being
able to change systems so they evolve with your needs.
---

class: center, middle

# Also...

.eighty[![the graph](images/products_and_categories_graph.png)]

???
We decided to model our data as a graph instead of a table so our system is easier to change and deals with complicated data without accreting complexity. This choice leaves us with an iteresting byproduct: a graph structure.
---
class: center, middle

# Abstracting...

.eighty[![the graph](images/abstracted_graph.png)]

???
It's pretty but what does it mean?
---

class: center, middle

.eighty[![arango strongly connected component](images/arango_strong_components.png)]

???

---

class: center, middle

## Call data
```sh
sqlite> select * from calls limit 5;
1|4||94970|2010-09-15 19:21:30|07434677419|2010-09-15 19:17:44|211|Incoming|2010-11-11 10:20:57|2010-11-11 10:20:57
2|23||95598|1980-02-11 07:19:15|01666472054|1980-02-11 07:18:23|31|Outgoing|2010-11-11 10:20:57|2010-11-11 10:20:57
3|23||95674|1980-02-11 07:46:38|07371326239|1980-02-11 07:45:42|45|Incoming|2010-11-11 10:20:57|2010-11-11 10:20:57
4|23|8|95725|1980-02-11 08:05:04|07681546436|1980-02-11 08:04:42|10|Outgoing|2010-11-11 10:20:57|2010-11-11 10:20:57
5|23|8|95728|1980-02-11 08:05:43|07681546436|1980-02-11 08:05:31|0|Outgoing|2010-11-11 10:20:57|2010-11-11 10:20:57
```

---

class: center, middle

# Questions?

* Github: @sleepycat
* Twitter: @dexterchief
* mike@korora.ca


    </textarea>
    <script src="out/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ratio: "16:9"});
    </script>
  </body>
</html>
