<!DOCTYPE html>
<html>
  <head>
    <title>Thinking in Graphs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="stylesheets/style.css" >
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Thinking in graphs

## Mike Williamson and Jen Schellinck

???
Most introductory talks about graphs are pretty abstract and math oriented. The aim here is to back into understanding graphs by showing how graphs can be used when storing and retrieving data.
We are going to look at graphs in two different contexts: a storage context and an analysis context.
---
class: center, middle

## When we think of data...

.seventy[![schema](images/excel.png)]

---
class: center, middle

## Relational data

.seventy[![schema](images/hr_schema.png)]

---
background-image: url(images/golden_hammer_bg.jpg)

???
Programmers are trained to be able bash data of any shape into the shape of a table.
What shape was the data before the golden hammer was weilded? Probably a graph.
Have we lost anything by bashing it into this new shape?
---
class: center, middle

.quote["No data is born relational" -- Dharma Shukla, Microsoft]

???
This is a really interesting quote from Microsoft Technical Fellow Dharma Shukla.
---

class: center, middle

# Types of graph

.eighty[![types](images/graph_types.png)]

???
---
class: center, middle

# Sequencing

.twenty[![dependency graph?](images/dependency_graph.png)]

???
Isn't that a dependency graph? Shouldn't we explicitly model the relationships?
---

class: center, middle

# Interconnections

.seventy[![connectome](images/connectome.jpg)]

???
---
class: center, middle

# Interconnections

.sixty[![saddam](images/saddam_sna.png)]

???
---

class: center, middle

# Heirarchy

.eighty[![explosion](images/parts_explosion.jpg)]

???
Heirarchical things
---

class: center, middle

# Data can be represented either way: tables or a graph
.eighty[![equivalent](images/equivalent.png)]

???
You are looking the same data represented on the left as tables and on the right as a graph.
When most people think of data, it's primarily tables or lists of data that comes to mind.
But this is not the only, or even best way to store all data.
The real world contains many things that are challenging to store in a standard database
---
class: center, middle

# Differences: Interconnection example

???
Any join operation could be considered a graph traversal.
Complicated relationships like authors/books or employees/projects are especially painful.
This is called a many to many relationship and it requires three tables in a relational database.
---
class: center, middle

# The many to many relationship

.eighty[![m2m](images/many_to_many.png)]

???
---
class: middle

## Relational setup

```sql
CREATE TABLE IF NOT EXISTS projects (
	id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
	name VARCHAR(45) NULL
);
CREATE TABLE IF NOT EXISTS employees (
	id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
	name VARCHAR(45) NULL
);
CREATE TABLE IF NOT EXISTS employees_projects (
	employee_id INT NOT NULL,
	project_id INT NOT NULL,
	PRIMARY KEY (project_id, employee_id),
	FOREIGN KEY(employee_id) REFERENCES employees(id),
	FOREIGN KEY(project_id) REFERENCES projects(id)
);

INSERT INTO employees VALUES (null, "Mike");
INSERT INTO projects VALUES (null, "Bigproj");
INSERT INTO employees_projects VALUES (1, 1);
```
???
Then a table structure is created and finally the categories and the numbers
which denote their level of nesting
---
class: middle

## What project is Mike working on?
```sql
select projects.name from employees
	inner join employees_projects
    on employees.id = employees_projects.employee_id
  inner join projects
    on employees_projects.project_id = projects.id;

Bigproj
```
???
---
class: middle

## Graph setup
```sh
db._createDocumentCollection('projects')
db._createDocumentCollection('employees')
db._createEdgeCollection('works_on')

INSERT {_key: "mike", name: "Mike"} INTO employees
INSERT {_key: "bigproj", name: "Bigproj"} INTO projects
INSERT {_to: "projects/bigproj", _from: "employees/mike"} INTO works_on
```
???
---
class: middle

## What project is Mike working on?
```sql
FOR v IN OUTBOUND "employees/mike" works_on RETURN v.name

[
  "Bigproj"
]
```
???
Low ceremony, no rules about what attributes a any of our vertices can have.
---
class: center, middle

# Differences: Heirarchy example

???
Heirarchical data is famously awkward to store in relational database.
We'll explore the Nested Sets design pattern and compare it with a graph approach.
---
class: center, middle

# Representing heirarchy in relational databases is awkward
.eighty[![categories](images/categories.png)]

???
---
class: center, middle

# A popular strategy: The Nested Sets pattern
.eighty[![numbered](images/nested_numbered.png)]

???
Here is the planning phase, where you decide what numbers the categories are
going to have relative to each other.
---
class: middle

## Nested Sets
```sql
CREATE TABLE nested_category (
	category_id INT AUTO_INCREMENT PRIMARY KEY,
	name VARCHAR(20) NOT NULL,
	lft INT NOT NULL,
	rgt INT NOT NULL
);

INSERT INTO nested_category VALUES(1,'ELECTRONICS',1,20),(2,'TELEVISIONS',2,9),(3,'TUBE',3,4),
 (4,'LCD',5,6),(5,'PLASMA',7,8),(6,'PORTABLE ELECTRONICS',10,19),(7,'MP3 PLAYERS',11,14),(8,'FLASH',12,13),
 (9,'CD PLAYERS',15,16),(10,'2 WAY RADIOS',17,18);
```
???
Then a table structure is created and finally the categories and the numbers
which denote their level of nesting
---
class: center, middle

# The actual data

```sql
SELECT * FROM nested_category ORDER BY category_id;

+-------------+----------------------+-----+-----+
| category_id | name                 | lft | rgt |
+-------------+----------------------+-----+-----+
|           1 | ELECTRONICS          |   1 |  20 |
|           2 | TELEVISIONS          |   2 |   9 |
|           3 | TUBE                 |   3 |   4 |
|           4 | LCD                  |   5 |   6 |
|           5 | PLASMA               |   7 |   8 |
|           6 | PORTABLE ELECTRONICS |  10 |  19 |
|           7 | MP3 PLAYERS          |  11 |  14 |
|           8 | FLASH                |  12 |  13 |
|           9 | CD PLAYERS           |  15 |  16 |
|          10 | 2 WAY RADIOS         |  17 |  18 |
+-------------+----------------------+-----+-----+
```
???
The result
---
class: center, middle

# Graph hierarchy: This isn't conceptual, it's literal

.eighty[![](images/graph_hierarchy.png)]

---
class: middle

# The actual data

```sh
//Categories collection
[
  {
    "_key" : "electronics",
    "_id" : "categories/electronics",
    "_rev" : "_VHhY1zy---",
    "name" : "electronics"
  },
  {
    "_key" : "televisions",
    "_id" : "categories/televisions",
    "_rev" : "_VHhZQkq---",
    "name" : "televisions"
  },
...
]
//Relations collection
[
  {
    "_key" : "1318642540530",
    "_id" : "relations/1318642540530",
    "_from" : "categories/televisions",
    "_to" : "categories/electronics",
    "_rev" : "_VHhcJMS---"
  },
...
]
```
???
A graph would simply have a collection of categories. Relations are not
calculated on the fly, they are saved as data as well: another collection
containing edges
---
class: center, middle

# Retrieving a full tree

---

class: middle

# Relational

```sh

SELECT node.name
FROM nested_category AS node,
	nested_category AS parent
WHERE node.lft BETWEEN parent.lft AND parent.rgt
	AND parent.name = 'ELECTRONICS'
ORDER BY node.lft;

+----------------------+
| name                 |
+----------------------+
| ELECTRONICS          |
| TELEVISIONS          |
| TUBE                 |
| LCD                  |
| PLASMA               |
| PORTABLE ELECTRONICS |
| MP3 PLAYERS          |
| FLASH                |
| CD PLAYERS           |
| 2 WAY RADIOS         |
+----------------------+
```
???
---
class: middle

# Graph

```sh
LET root = DOCUMENT("categories/electronics")
LET subcategories = (FOR v IN 1..3 INBOUND root relations RETURN v.name)
RETURN FLATTEN([root.name, subcategories])

[
	"electronics",
	"televisions",
	"lcd",
	"plasma",
	"tube",
	"portable electronics",
	"mp3 players",
	"flash",
	"2 way radios",
	"cd players"
]
```
???
---
class: center, middle

# Finding all the leaf nodes

(categories with no categories beneath them)

---

class: middle

# Relational

```sh
SELECT name
FROM nested_category
WHERE rgt = lft + 1;

+--------------+
| name         |
+--------------+
| TUBE         |
| LCD          |
| PLASMA       |
| FLASH        |
| CD PLAYERS   |
| 2 WAY RADIOS |
+--------------+
```
???
---
class: middle

# Graph

```sh
FOR vertex IN 2..3 INBOUND "categories/electronics" relations
  FILTER LENGTH(FOR v IN 1 INBOUND vertex relations RETURN v) == 0
    RETURN vertex.name

[
  "lcd",
  "plasma",
  "tube",
  "flash",
  "2 way radios",
  "cd players"
]
```
???
---
class: center, middle

# Find the immediate subordinates of a node

---

class: middle

# Relational

```sql
SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth
FROM nested_category AS node,
	nested_category AS parent,
	nested_category AS sub_parent,
	(
		SELECT node.name, (COUNT(parent.name) - 1) AS depth
		FROM nested_category AS node,
						nested_category AS parent
		WHERE node.lft BETWEEN parent.lft AND parent.rgt
						AND node.name = 'PORTABLE ELECTRONICS'
		GROUP BY node.name
		ORDER BY node.lft
	)AS sub_tree
WHERE node.lft BETWEEN parent.lft AND parent.rgt
	AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt
	AND sub_parent.name = sub_tree.name
GROUP BY node.name
HAVING depth &lt= 1
ORDER BY node.lft;

+----------------------+-------+
| name                 | depth |
+----------------------+-------+
| PORTABLE ELECTRONICS |     0 |
| MP3 PLAYERS          |     1 |
| CD PLAYERS           |     1 |
| 2 WAY RADIOS         |     1 |
+----------------------+-------+
```
???
---
class: middle

# Graph

```sql
LET root = DOCUMENT("categories/portable_electronics")
LET subcategories = (FOR v,e,p IN INBOUND root relations RETURN {name: v.name, depth: LENGTH(p.edges)})
RETURN UNSHIFT(subcategories, {name: root.name, depth: 0})

[
  [
    { "name" : "portable electronics", "depth" : 0 },
    { "name" : "mp3 players", "depth" : 1 },
    { "name" : "2 way radios", "depth" : 1 },
    { "name" : "cd players", "depth" : 1 }
  ]
]
```
???
---
class: center, middle

# Adding a category

What if we want to add a "game consoles" category?

---
class: center, middle

# Renumbering
.eighty[![numbered](images/nested_numbered.png)]

---
class: middle

```sql
LOCK TABLE nested_category WRITE;

SELECT @myRight := rgt FROM nested_category
WHERE name = 'TELEVISIONS';

UPDATE nested_category SET rgt = rgt + 2 WHERE rgt > @myRight;
UPDATE nested_category SET lft = lft + 2 WHERE lft > @myRight;

INSERT INTO nested_category(name, lft, rgt) VALUES('GAME CONSOLES', @myRight + 1, @myRight + 2);

UNLOCK TABLES;
```
???
---
class: center, middle

# Renumbering: before

```sql
SELECT * FROM nested_category ORDER BY category_id;

+-------------+----------------------+-----+-----+
| category_id | name                 | lft | rgt |
+-------------+----------------------+-----+-----+
|           1 | ELECTRONICS          |   1 |  20 |
|           2 | TELEVISIONS          |   2 |   9 |
|           3 | TUBE                 |   3 |   4 |
|           4 | LCD                  |   5 |   6 |
|           5 | PLASMA               |   7 |   8 |
|           6 | PORTABLE ELECTRONICS |  10 |  19 |
|           7 | MP3 PLAYERS          |  11 |  14 |
|           8 | FLASH                |  12 |  13 |
|           9 | CD PLAYERS           |  15 |  16 |
|          10 | 2 WAY RADIOS         |  17 |  18 |
+-------------+----------------------+-----+-----+
```
---
class: center, middle

# Renumbering: after

```sql
SELECT * FROM nested_category ORDER BY category_id;

+-------------+----------------------+-----+-----+
| category_id | name                 | lft | rgt |
+-------------+----------------------+-----+-----+
|           1 | ELECTRONICS          |   1 |  22 |
|           2 | TELEVISIONS          |   2 |   9 |
|           3 | TUBE                 |   3 |   4 |
|           4 | LCD                  |   5 |   6 |
|           5 | PLASMA               |   7 |   8 |
|           6 | PORTABLE ELECTRONICS |  12 |  21 |
|           7 | MP3 PLAYERS          |  13 |  16 |
|           8 | FLASH                |  14 |  15 |
|           9 | CD PLAYERS           |  17 |  18 |
|          10 | 2 WAY RADIOS         |  19 |  20 |
|          11 | GAME CONSOLES        |  10 |  11 |
+-------------+----------------------+-----+-----+
```
---
class: middle

# Graph

```sql
//insert new category
INSERT {_key: "game_consoles", name: "game consoles"} INTO categories RETURN NEW
[
  {
    "_key" : "game_consoles",
    "_id" : "categories/game_consoles",
    "_rev" : "_VHiIXoK---",
    "name" : "game consoles"
  }
]

//insert a edge connecting the new category to it's parent
INSERT {_to: "categories/electronics", _from: "categories/game_consoles"} INTO relations RETURN NEW
[
  {
    "_key" : "1318642543842",
    "_id" : "relations/1318642543842",
    "_from" : "categories/game_consoles",
    "_to" : "categories/electronics",
    "_rev" : "_VHiKUvu---"
  }
]

```
???

---
class: center, middle

# Our new hierarchy

.ninetyfive[![plus game consoles](images/hierarchy_plus_game_consoles.png)]

???
---
class: center, middle

# What did this graph stuff get us?

* Change is easier for systems built like this
* Data complexity does not mean system/code complexity
* Less upfront planning/no "sql design patterns"
* Scaling == more machines

???
Queries are an interesting point of comparison but the real value is in being
able to change systems so they evolve with your needs.
---
class: center, middle

# Our graph data

.ninetyfive[![plus game consoles](images/graph_hierarchy.png)]

???
We decided to model our data as a graph instead of a table so our system is easier to change and deals with complicated data without accreting complexity. This choice leaves us with an interesting byproduct: a graph structure.
---

class: center, middle

# An interesting byproduct: graph structure

.sixty[![the graph](images/structure_without_games.png)]

---
class: center, middle

# Structure with meaning

.sixty[![the graph](images/structure_without_games_unlabeled.png)]

---
class: center, middle

# Structure with meaning

.ninety[![call structure](images/call_structure.png)]

---
class: center, middle

# Meaningful structure

---

class: center, middle

# Graph Structure

.twenty[![snowflakegraphic](images/r_pics/stargraph.png)]

---
class: center, middle

# Arango DB to R

.fifty[![schema](images/r_pics/arangotor.png)]

---

class: center, middle

## Call data
```sh
sqlite> select * from calls limit 5;
1|4||94970|2010-09-15 19:21:30|07434677419|2010-09-15 19:17:44|211|Incoming|2010-11-11 10:20:57|2010-11-11 10:20:57
2|23||95598|1980-02-11 07:19:15|01666472054|1980-02-11 07:18:23|31|Outgoing|2010-11-11 10:20:57|2010-11-11 10:20:57
3|23||95674|1980-02-11 07:46:38|07371326239|1980-02-11 07:45:42|45|Incoming|2010-11-11 10:20:57|2010-11-11 10:20:57
4|23|8|95725|1980-02-11 08:05:04|07681546436|1980-02-11 08:04:42|10|Outgoing|2010-11-11 10:20:57|2010-11-11 10:20:57
5|23|8|95728|1980-02-11 08:05:43|07681546436|1980-02-11 08:05:31|0|Outgoing|2010-11-11 10:20:57|2010-11-11 10:20:57
```

---
class: center, middle

# A Visualization of the Phone Call Dataset

.seventy[![schema](images/r_pics/phonecallgraphvis.png)]


---
class: center, middle

# World to Graph and Back Again

.seventy[![schema](images/r_pics/worldtograph.png)]


---

class: center, middle

# Back to the Phone Call Dataset

.seventy[![schema](images/r_pics/phonecallgraphvis.png)]

class: center, middle

---
class: center, middle

# Options for Phone Calling Patterns

.fifty[![schema](images/r_pics/callpatterns.png)]


---
class: center, middle

# People Who Received Phone Calls but Never Made Them

.seventy[![schema](images/r_pics/phonecallsinnotout.png)]

---
class: center, middle
# Sales People and Clients

.fifty[![schema](images/r_pics/sellersandclients.png)]

---
class: center, middle

# Interpreting the Call Patterns

.fifty[![schema](images/r_pics/graphthreecolours.png)]

---
class: center, middle

# A Subgraph of Only Sales People

.fifty[![schema](images/r_pics/sellersrelationships.png)]

---
class: center, middle

# An Interpretation of the Sales People Subgraph

.fifty[![schema](images/r_pics/graphmaybeloners.png)]

---
class: center, middle

# Which sales people are a "social bridge"?

.fifty[![schema](images/r_pics/graphbetweeness.png)]

---
class: middle

# Automating those insights

```sql
db._useDatabase('calls')
var pregel = require("@arangodb/pregel");
var handle = pregel.start("linerank", "calls", {"resultField": "rank"});
db._query('FOR account IN accounts LIMIT 1 RETURN account').toArray()
[
  {
    "_key" : "2327",
    "_id" : "accounts/2327",
    "_rev" : "_VH5RrY----",
    "rank" : 0.00036823938717134297
  }
]
```

---

class: center, middle

# Visualizing our ranked data

.ninety[![schema](images/webgl_arangodb.png)]

---

class: center, middle

# Questions?

## datascienceexpertsgroup.com

#### Jen Schellinck
* Github: @jschellinck
* Twitter: @JSchellinck
* jschellinck@sysabee.com

#### Mike Williamson
* Github: @sleepycat
* Twitter: @dexterchief
* mike@korora.ca


    </textarea>
    <script src="out/remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ratio: "16:9"});
    </script>
  </body>
</html>
